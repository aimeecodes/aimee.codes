I"Aµ<p>In my last post about the Iowa housing data set, I spent some time working with a specific logical flow for filling categorical NA values - you can find that post <a href="/blog/2020/11/11/filling-NA-values">here</a>.
In the post previous to that, I visualized some features, using a lot of box / violin plots, count plots, and some linear regression scatter plots comparing the distribution of SalePrices when sorted by specific features. If you would like a refresher, check that post out <a href="/blog/2020/08/05/iowa-housing-exploration">here</a>.</p>

<p>In this post, I‚Äôm going to walk through my process of cleaning the data in order to retain as much information as possible. Thanks to Kaggle users <a href="https://www.kaggle.com/datafan07">Ertuƒürul Demir</a> and <a href="https://www.kaggle.com/goldens">Golden</a> for posting their in-depth notebooks. Both contain a wealth of information and provide a great starting base for other novice data analysts.</p>

<p><br /></p>

<hr />

<h3 id="examining-the-missing-data">Examining the Missing Data</h3>

<p>By now, I‚Äôm quite familiar with this data set - but it won‚Äôt hurt us to generate a table of values specifically to highlight our missing data!</p>

<p>The first thing I want to do is examine the null / <code>NA</code> values in both of the train and test datasets. To do this, we‚Äôll have three datasets: <code>train_data</code>, <code>test_data</code>, and <code>merged_data</code>. The <code>merged_data</code> dataset has all of our samples from both of the train and test datasets without the <code>SalePrice</code> feature, which will make it easier for us to look at the aggregated data.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="c1"># create features dataframes,
# dropping SalePrice from
# train_features
</span><span class="n">train_features</span> <span class="o">=</span>
  <span class="n">train_data</span><span class="p">.</span><span class="n">drop</span><span class="p">(</span>
    <span class="p">[</span><span class="s">'SalePrice'</span><span class="p">],</span>
     <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">test_features</span> <span class="o">=</span>
  <span class="n">test_data</span>

<span class="c1"># merge the two data sets
# for analysis, and reset index
</span><span class="n">merged_data</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="n">concat</span><span class="p">(</span>
  <span class="p">[</span><span class="n">train_features</span><span class="p">,</span>
   <span class="n">test_features</span><span class="p">]).</span><span class="n">reset_index</span><span class="p">(</span>
    <span class="n">drop</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="n">datasets</span> <span class="o">=</span> <span class="p">[</span><span class="n">train_data</span><span class="p">,</span>
  <span class="n">test_data</span><span class="p">,</span>
  <span class="n">merged_data</span><span class="p">]</span></code></pre></figure>

<p>Having an array of datasets will come in handy later when we need to access each dataset to make any adjustments.</p>

<p>Using <code>merged_data</code>, I created a summary table with three purposes:</p>

<p>(1) Calculate how many samples have <code>NA</code>s for each feature,</p>

<p>(2) Describe the data type of each feature,</p>

<p>(3) Give a list of unique values for each categorical feature, and a min / max / mean / median summary for each numerical feature.</p>

<p>This is easily visualized in the table below:</p>

<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th class="text">Feature</th>
      <th class="numeric">NA Count</th>
      <th class="numeric">% Missing</th>
      <th class="text">Data Type</th>
      <th class="text">Overview</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th data-title="Feature" class="text">PoolQC</th>
      <td data-title="NA Count" class="numeric">2909</td>
      <td data-title="% Missing" class="numeric">0.99657</td>
      <td data-title="Data Type" class="text">object</td>
      <td data-title="Overview" class="text">[nan, Ex, Fa, Gd]</td>
    </tr>
    <tr>
      <th data-title="Feature" class="text">MiscFeature</th>
      <td data-title="NA Count" class="numeric">2814</td>
      <td data-title="% Missing" class="numeric">0.96403</td>
      <td data-title="Data Type" class="text">object</td>
      <td data-title="Overview" class="text">[nan, Shed, Gar2, Othr, TenC]</td>
    </tr>
    <tr>
      <th class="styling-space">...</th>
      <td class="disappearing">...</td>
      <td class="disappearing">...</td>
      <td class="disappearing">...</td>
      <td class="disappearing">...</td>
    </tr>
  </tbody>
</table>

<p><a class="read-more-link" href="/assets/missing-values-summary.html"> See full table </a></p>

<p>The script that generated this table is available on <a href="https://github.com/aimosjo/aimee.codes/blob/main/assets/code/missingValuesSummary.py">my github</a>.</p>

<p>We‚Äôve got our work laid out, time to start cleaning!
<br /></p>

<hr />

<h3 id="filling-the-missing-data">Filling the Missing Data</h3>

<h4 id="categorical-features-with-na--nan-which-mean-none">Categorical Features with ‚ÄúNA / nan‚Äù which mean ‚ÄúNone‚Äù</h4>

<p>For many of the categorical features, <code>NA</code> is used if the sample doesn‚Äôt contain the given feature. For these samples, we will change the sample feature to <code>None</code> instead.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">none_cols</span> <span class="o">=</span> <span class="p">[</span>
  <span class="s">'PoolQC'</span><span class="p">,</span>
  <span class="s">'MiscFeature'</span><span class="p">,</span>
  <span class="s">'Alley'</span><span class="p">,</span>
  <span class="s">'Fence'</span><span class="p">,</span>
  <span class="s">'FireplaceQu'</span><span class="p">,</span>
  <span class="s">'GarageFinish'</span><span class="p">,</span>
  <span class="s">'GarageQual'</span><span class="p">,</span>
  <span class="s">'GarageCond'</span><span class="p">,</span>
  <span class="s">'GarageType'</span><span class="p">,</span>
  <span class="s">'BsmtCond'</span><span class="p">,</span>
  <span class="s">'BsmtExposure'</span><span class="p">,</span>
  <span class="s">'BsmtQual'</span><span class="p">,</span>
  <span class="s">'BsmtFinType1'</span><span class="p">,</span>
  <span class="s">'BsmtFinType2'</span><span class="p">,</span>
  <span class="s">'MasVnrType'</span>
<span class="p">]</span>

<span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">none_cols</span><span class="p">:</span>
  <span class="k">for</span> <span class="n">ds</span> <span class="ow">in</span> <span class="n">datasets</span><span class="p">:</span>
      <span class="n">ds</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> 
        <span class="n">ds</span><span class="p">[</span><span class="n">col</span><span class="p">].</span><span class="n">fillna</span><span class="p">(</span><span class="s">"None"</span><span class="p">)</span></code></pre></figure>

<p><br /></p>
<hr width="40%" />

<p><br /></p>
<h4 id="numerical-features-with-na--nan-which-mean-0">Numerical features with ‚ÄúNA / nan‚Äù which mean 0</h4>

<p>These numerical features just need 0 instead of <code>NA</code>, since for these samples, the feature doesn‚Äôt exist.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">zero_cols</span> <span class="o">=</span> <span class="p">[</span>
  <span class="s">'GarageYrBlt'</span><span class="p">,</span>
  <span class="s">'MasVnrArea'</span><span class="p">,</span>
  <span class="s">'BsmtFullBath'</span><span class="p">,</span>
  <span class="s">'BsmtHalfBath'</span><span class="p">,</span>
  <span class="s">'BsmtFinSF1'</span><span class="p">,</span>
  <span class="s">'BsmtFinSF2'</span><span class="p">,</span>
  <span class="s">'BsmtUnfSF'</span><span class="p">,</span>
  <span class="s">'TotalBsmtSF'</span><span class="p">]</span>

<span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">zero_cols</span><span class="p">:</span>
  <span class="k">for</span> <span class="n">ds</span> <span class="ow">in</span> <span class="n">datasets</span><span class="p">:</span>
      <span class="n">ds</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span>
        <span class="n">ds</span><span class="p">[</span><span class="n">col</span><span class="p">].</span><span class="n">fillna</span><span class="p">(</span>
        <span class="mi">0</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span></code></pre></figure>

<p><br /></p>
<hr width="40%" />

<p><br /></p>
<h4 id="categorical-features-with-na--nan-which-need-examination">Categorical features with ‚ÄúNA / nan‚Äù which need examination</h4>

<p>These are categorical features which are missing from 1-4 samples.</p>

<h4 id="mszoning--exterior1st--exterior2nd">MSZoning / Exterior1st / Exterior2nd</h4>

<p><em>Filling <code>MSZoning</code> is the subject of another post, which can be found <a href="/blog/2020/11/11/filling-NA-values">here</a>!</em></p>

<p>Since the distribution of values for <code>MSZoning</code>, <code>Exterior1st</code>, and <code>Exterior2nd</code> appear to depend on which <code>Neighborhood</code> the house is located in, we need to group our features by <code>Neighborhood</code>, then use the mode of the given feature to fill in the NAs.</p>

<p>There is only 1 sample that is missing both Exterior1st and Exterior2nd features, and it is in the Edwards <code>Neighborhood</code>:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">mask1</span> <span class="o">=</span> <span class="n">merged_data</span><span class="p">[</span> 
  <span class="s">'Exterior1st'</span><span class="p">].</span><span class="n">isna</span><span class="p">()</span>
<span class="n">mask2</span> <span class="o">=</span> <span class="n">merged_data</span><span class="p">[</span> 
  <span class="s">'Exterior2nd'</span><span class="p">].</span><span class="n">isna</span><span class="p">()</span>
<span class="n">merged_data</span><span class="p">[</span><span class="n">mask1</span> <span class="o">&amp;</span> <span class="n">mask2</span><span class="p">]</span>
  <span class="p">[</span><span class="s">'ExterQual'</span><span class="p">,</span>
  <span class="s">'ExterCond'</span><span class="p">,</span>
  <span class="s">'Neighborhood'</span><span class="p">]</span>

      <span class="n">EQ</span>  <span class="n">EC</span>  <span class="n">Neighborhood</span>
<span class="mi">2151</span>  <span class="n">TA</span>   <span class="mi">3</span>  <span class="n">Edwards</span></code></pre></figure>

<p>To make an accurate prediction, we can examine other houses in the Edwards <code>Neighborhood</code> with identical <code>ExterQual</code> and <code>ExterCond</code> values to see what the distribution looks like:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">mask3</span> <span class="o">=</span> <span class="n">merged_data</span><span class="p">[</span>
  <span class="s">'Neighborhood'</span><span class="p">]</span> <span class="o">==</span> <span class="s">'Edwards'</span>
<span class="n">mask4</span> <span class="o">=</span> <span class="n">merged_data</span><span class="p">[</span>
  <span class="s">'ExterQual'</span><span class="p">]</span> <span class="o">==</span> <span class="s">'TA'</span>
<span class="n">mask5</span> <span class="o">=</span> <span class="n">merged_data</span><span class="p">[</span>
  <span class="s">'ExterCond'</span><span class="p">]</span> <span class="o">==</span> <span class="s">'TA'</span>

<span class="n">merged_data</span><span class="p">[</span><span class="n">mask3</span>
  <span class="o">&amp;</span> <span class="n">mask4</span> <span class="o">&amp;</span> <span class="n">mask5</span><span class="p">][[</span>
  <span class="s">'Exterior1st'</span><span class="p">,</span>
  <span class="s">'Exterior2nd'</span><span class="p">]].</span><span class="n">value_counts</span><span class="p">()</span>

<span class="n">Exterior1st</span>  <span class="n">Exterior2nd</span>
<span class="n">Wd</span> <span class="n">Sdng</span>      <span class="n">Wd</span> <span class="n">Sdng</span>        <span class="mi">36</span>
<span class="n">MetalSd</span>      <span class="n">MetalSd</span>        <span class="mi">28</span>
<span class="n">VinylSd</span>      <span class="n">VinylSd</span>        <span class="mi">22</span>
<span class="n">Plywood</span>      <span class="n">Plywood</span>        <span class="mi">12</span>
<span class="n">HdBoard</span>      <span class="n">HdBoard</span>         <span class="mi">9</span>
<span class="n">WdShing</span>      <span class="n">Wd</span> <span class="n">Shng</span>         <span class="mi">9</span>
<span class="n">HdBoard</span>      <span class="n">Plywood</span>         <span class="mi">5</span>
<span class="n">Stucco</span>       <span class="n">Stucco</span>          <span class="mi">4</span>
<span class="n">WdShing</span>      <span class="n">Plywood</span>         <span class="mi">4</span>
<span class="n">BrkFace</span>      <span class="n">Wd</span> <span class="n">Sdng</span>         <span class="mi">3</span>
<span class="n">AsbShng</span>      <span class="n">Plywood</span>         <span class="mi">2</span>
             <span class="n">AsbShng</span>         <span class="mi">2</span>
<span class="n">Plywood</span>      <span class="n">Wd</span> <span class="n">Shng</span>         <span class="mi">1</span>
<span class="n">VinylSd</span>      <span class="n">Wd</span> <span class="n">Sdng</span>         <span class="mi">1</span>
<span class="n">MetalSd</span>      <span class="n">Wd</span> <span class="n">Sdng</span>         <span class="mi">1</span>
             <span class="n">HdBoard</span>         <span class="mi">1</span>
<span class="n">Wd</span> <span class="n">Sdng</span>      <span class="n">Plywood</span>         <span class="mi">1</span>
<span class="n">BrkFace</span>      <span class="n">Plywood</span>         <span class="mi">1</span>
<span class="n">BrkComm</span>      <span class="n">Brk</span> <span class="n">Cmn</span>         <span class="mi">1</span>
<span class="n">AsphShn</span>      <span class="n">AsphShn</span>         <span class="mi">1</span></code></pre></figure>

<p>From the above result, we should be able to see Wd Sdng is the most common <code>Exterior1st</code> and <code>Exterior2nd</code> value for homes in the Edwards <code>Neighborhood</code> with TA for both <code>ExterQual</code> and <code>ExterCond</code> values. This is the value we want assigned to both <code>Exterior1st</code> and <code>Exterior2nd</code> for the missing value.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">nbh_mode_list</span> <span class="o">=</span> <span class="p">[</span><span class="s">'MSZoning'</span><span class="p">,</span>
  <span class="s">'Exterior1st'</span><span class="p">,</span>
  <span class="s">'Exterior2nd'</span><span class="p">]</span>

<span class="k">for</span> <span class="n">ds</span> <span class="ow">in</span> <span class="n">datasets</span><span class="p">:</span>
  <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">nbh_mode_list</span><span class="p">:</span>
    <span class="n">ds</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span>
      <span class="n">ds</span><span class="p">[</span><span class="n">col</span><span class="p">].</span><span class="n">fillna</span><span class="p">(</span>
      <span class="n">ds</span><span class="p">.</span><span class="n">groupby</span><span class="p">(</span><span class="s">'Neighborhood'</span><span class="p">)</span>
      <span class="p">[</span><span class="n">col</span><span class="p">].</span><span class="n">transform</span><span class="p">(</span>
      <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span>
        <span class="n">x</span><span class="p">.</span><span class="n">mode</span><span class="p">().</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span></code></pre></figure>

<h4 id="functional">Functional</h4>

<p>It appears <code>Functional</code> measures how many safety deductions the house has / how much overall damage there is. I started this investigation by examining 4 features: <code>OverallCond</code>, <code>BsmtCond</code>, <code>ExterCond</code>, and <code>GarageCond</code>. These features could give us an idea of any damage to the home, and if <code>Functional</code> is affected.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">condFeatures</span> <span class="o">=</span> <span class="p">[</span>
  <span class="s">'OverallCond'</span><span class="p">,</span>
  <span class="s">'BsmtCond'</span><span class="p">,</span>
  <span class="s">'ExterCond'</span><span class="p">,</span>
  <span class="s">'GarageCond'</span><span class="p">]</span></code></pre></figure>

<p>First, only 2 samples from the test set are missing this feature:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">mask4</span> <span class="o">=</span> <span class="n">merged_data</span><span class="p">[</span>
<span class="s">'Functional'</span><span class="p">].</span><span class="n">isna</span><span class="p">()</span>

<span class="n">merged_data</span><span class="p">[</span><span class="n">mask4</span><span class="p">][</span>
  <span class="p">[</span><span class="s">'Id'</span><span class="p">,</span>
   <span class="s">'Functional'</span><span class="p">]</span> <span class="o">+</span>
  <span class="n">condFeatures</span><span class="p">]</span>

<span class="n">Id</span>     <span class="n">Func</span>  <span class="n">OvC</span> <span class="n">BC</span>   <span class="n">EC</span>  <span class="n">GC</span>
<span class="mi">2217</span>   <span class="n">NaN</span>    <span class="mi">5</span>  <span class="bp">None</span> <span class="n">Po</span>  <span class="n">Po</span>
<span class="mi">2474</span>   <span class="n">NaN</span>    <span class="mi">1</span>  <span class="n">Fa</span>   <span class="n">Fa</span>  <span class="n">Fa</span></code></pre></figure>

<p>Something a little funky to notice here: While house with <code>Id</code> 2217 has no basement, poor exterior condition, and poor garage condition, it still has an overall condition score of 5, while house with <code>Id</code> 2474 has a fair basement, fair exterior condition, and fair garage condition still only has an overall condition rating of 1. This doesn‚Äôt really make sense under my hypothesis of a higher condition rating correlating with a higher functionality rating, so we had better keep investigating.</p>

<p>We need to get the data looking like something we can numerically manipulate. This will take two steps:</p>

<p>(1) Pop out all of these features into a separate deep copied dataframe so none of my fiddling will affect the underlying data.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">mask5</span> <span class="o">=</span> <span class="n">merged_data</span><span class="p">[</span><span class="s">'Functional'</span><span class="p">].</span><span class="n">isna</span><span class="p">()</span>
<span class="n">condfeatdf</span> <span class="o">=</span> <span class="n">merged_data</span><span class="p">[</span><span class="o">~</span><span class="n">mask5</span><span class="p">][</span>
  <span class="p">[</span><span class="s">'Id'</span><span class="p">,</span>
   <span class="s">'Functionality'</span><span class="p">,</span>
   <span class="n">condFeatures</span><span class="p">]].</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="n">Id</span>   <span class="n">Func</span>  <span class="n">OC</span> 	<span class="n">BC</span>   <span class="n">EC</span>   <span class="n">GC</span>
<span class="mi">1</span>    <span class="n">Typ</span>   <span class="mi">5</span> 	<span class="n">TA</span>   <span class="n">TA</span>   <span class="n">TA</span>
<span class="mi">2</span>    <span class="n">Typ</span>   <span class="mi">8</span> 	<span class="n">TA</span>   <span class="n">TA</span>   <span class="n">TA</span>
<span class="mi">3</span>    <span class="n">Typ</span>   <span class="mi">5</span> 	<span class="n">TA</span>   <span class="n">TA</span>   <span class="n">TA</span>
<span class="mi">4</span>    <span class="n">Typ</span>   <span class="mi">5</span> 	<span class="n">Gd</span>   <span class="n">TA</span>   <span class="n">TA</span>
<span class="mi">5</span>    <span class="n">Typ</span>   <span class="mi">5</span> 	<span class="n">TA</span>   <span class="n">TA</span>   <span class="n">TA</span>
<span class="p">...</span>  <span class="p">...</span>   <span class="p">...</span> 	<span class="p">...</span>  <span class="p">...</span>  <span class="p">...</span></code></pre></figure>

<p>(2) Encode these variables as integers instead of categorical variables despite my lingering doubts about the linearity of the condition scale (we don‚Äôt know the exact differences between a ‚ÄòPo‚Äô house and a ‚ÄòFa‚Äô house) so we can actually perform a correlation test between all of the selected features.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">cond_map</span> <span class="o">=</span> <span class="p">{</span>
  <span class="s">'None'</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
  <span class="s">'Po'</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
  <span class="s">'Fa'</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
  <span class="s">'TA'</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
  <span class="s">'Gd'</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span>
  <span class="s">'Ex'</span><span class="p">:</span> <span class="mi">5</span>
<span class="p">}</span>
<span class="n">func_map</span> <span class="o">=</span> <span class="p">{</span>
  <span class="s">'Sal'</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
  <span class="s">'Sev'</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
  <span class="s">'Maj2'</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
  <span class="s">'Maj1'</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
  <span class="s">'Mod'</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span>
  <span class="s">'Min2'</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
  <span class="s">'Min1'</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span>
  <span class="s">'Typ'</span><span class="p">:</span> <span class="mi">7</span>
<span class="p">}</span>

<span class="k">for</span> <span class="n">feat</span> <span class="ow">in</span> <span class="n">condFeatures</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
  <span class="n">condfeatdf</span><span class="p">[</span><span class="n">feat</span><span class="p">]</span> <span class="o">=</span>
    <span class="n">condfeatdf</span><span class="p">[</span><span class="n">feat</span><span class="p">].</span><span class="nb">map</span><span class="p">(</span>
     <span class="n">cond_map</span><span class="p">).</span><span class="n">astype</span><span class="p">(</span><span class="s">'int'</span><span class="p">)</span>
<span class="n">condfeatdf</span><span class="p">[</span><span class="s">'Functional'</span><span class="p">]</span> <span class="o">=</span>
  <span class="n">condfeatdf</span><span class="p">[</span><span class="s">'Functional'</span><span class="p">].</span><span class="nb">map</span><span class="p">(</span>
    <span class="n">func_map</span><span class="p">).</span><span class="n">astype</span><span class="p">(</span><span class="s">'int'</span><span class="p">)</span>

<span class="n">Id</span>  <span class="n">Func</span>  <span class="n">OC</span>  <span class="n">BC</span>  <span class="n">EC</span>  <span class="n">GC</span>
<span class="mi">1</span>   <span class="mi">7</span> 	  <span class="mi">5</span>   <span class="mi">3</span>   <span class="mi">3</span>   <span class="mi">3</span>
<span class="mi">2</span>   <span class="mi">7</span> 	  <span class="mi">8</span>   <span class="mi">3</span>   <span class="mi">3</span>   <span class="mi">3</span>
<span class="mi">3</span>   <span class="mi">7</span>     <span class="mi">5</span>   <span class="mi">3</span>   <span class="mi">3</span>   <span class="mi">3</span>
<span class="mi">4</span>   <span class="mi">7</span>     <span class="mi">5</span>   <span class="mi">4</span>   <span class="mi">3</span>   <span class="mi">3</span>
<span class="mi">5</span>   <span class="mi">7</span>     <span class="mi">5</span>   <span class="mi">3</span>   <span class="mi">3</span>   <span class="mi">3</span></code></pre></figure>

<p>That looks better! Now we can attempt some numerical manipulations:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">condfeatdf</span><span class="p">.</span><span class="n">corr</span><span class="p">()[</span><span class="mi">1</span><span class="p">:][</span>
  <span class="p">[</span><span class="s">'Functional'</span><span class="p">,</span>
   <span class="s">'OverallCond'</span><span class="p">,</span>
   <span class="s">'BsmtCond'</span><span class="p">,</span>
   <span class="s">'ExterCond'</span><span class="p">,</span>
   <span class="s">'GarageCond'</span><span class="p">]]</span>

     <span class="n">OC</span>     <span class="n">BC</span>     <span class="n">EC</span>     <span class="n">GC</span>
<span class="n">Func</span> <span class="mf">0.118</span>  <span class="mf">0.190</span>  <span class="mf">0.074</span>  <span class="mf">0.090</span>
<span class="n">OC</span>          <span class="mf">0.090</span>  <span class="mf">0.403</span>  <span class="mf">0.045</span>
<span class="n">BC</span>                 <span class="mf">0.096</span>  <span class="mf">0.140</span>
<span class="n">EC</span>                        <span class="mf">0.093</span></code></pre></figure>

<p>This doesn‚Äôt bode well for my hypothesis at all - if we consider the condition scales linear, then the feature with the highest correlation to <code>Functional</code> is <code>BsmtCond</code> with a value of only 0.19.</p>

<p>Another issue is that many homes have a <code>BsmtCond</code> value of 0 under the new mapping, and it is not immediately clear that if a house has a <code>BsmtCond</code> of 0, it does not have a lower quality basement than a home with a <code>BsmtCond</code> value of 1. There are a lot of assumptions here, and frankly for only 2 missing values, this entire expedition may have been overkill. Ultimately, we will fill the two <code>NA</code> values with the mode, and fondly remember how to use <code>map</code> for the next time we need to change from a categorical variable to a numerical one. Good thing I made a deep copy to play around with instead!</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">for</span> <span class="n">ds</span> <span class="ow">in</span> <span class="n">datasets</span><span class="p">:</span>
  <span class="n">ds</span><span class="p">[</span><span class="s">'Functional'</span><span class="p">]</span> <span class="o">=</span>
    <span class="n">ds</span><span class="p">[</span><span class="s">'Functional'</span><span class="p">].</span><span class="n">fillna</span><span class="p">(</span>
    <span class="n">ds</span><span class="p">[</span><span class="s">'Functional'</span><span class="p">].</span><span class="n">mode</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span></code></pre></figure>

<h4 id="electrical--kitchenqual--saletype--utilities">Electrical / KitchenQual / SaleType / Utilities</h4>

<p>For these variables, there‚Äôs only 1-2 samples missing each feature, so we will fill them with the mode of the feature from the dataset.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="p">(</span>
  <span class="s">'Electrical'</span><span class="p">,</span>
  <span class="s">'KitchenQual'</span><span class="p">,</span>
  <span class="s">'SaleType'</span><span class="p">,</span>
  <span class="s">'Utilities'</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">ds</span> <span class="ow">in</span> <span class="n">datasets</span><span class="p">:</span>
      <span class="n">ds</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">ds</span><span class="p">[</span><span class="n">col</span><span class="p">].</span><span class="n">fillna</span><span class="p">(</span>
        <span class="n">ds</span><span class="p">[</span><span class="n">col</span><span class="p">].</span><span class="n">mode</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span></code></pre></figure>

<p><br /></p>
<hr width="40%" />

<p><br /></p>
<h4 id="numerical-features-with-na--nan-which-need-examination">Numerical features with ‚ÄúNA / nan‚Äù which need examination</h4>

<p>There‚Äôs a little more happening here than what appears at surface level, so let‚Äôs take a deeper dive into these features:</p>

<h4 id="lotfrontage">LotFrontage</h4>

<p>This is one of the features which a significant number of samples (486 / 2919) are missing. Lot frontage is defined as ‚Äúlinear feet of street connected to property.‚Äù Certainly we can draw the conclusion that <code>LotArea</code> might be correlated to <code>LotFrontage</code> since one is used to calculate the other, but there are a few other features that can help us interpolate.</p>

<p>First, let‚Äôs see the correlation between <code>LotArea</code> and <code>LotFrontage</code>.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">merged_data</span><span class="p">[</span>
  <span class="p">[</span><span class="s">'LotArea'</span><span class="p">,</span> \
  <span class="s">'LotFrontage'</span><span class="p">]].</span><span class="n">corr</span><span class="p">()</span>

    <span class="n">LotArea</span>   <span class="n">LotFrontage</span>
<span class="n">LA</span>  <span class="mf">1.000000</span>  <span class="mf">0.489896</span>
<span class="n">LF</span>  <span class="mf">0.489896</span>  <span class="mf">1.000000</span></code></pre></figure>

<p>0.48 isn‚Äôt a very strong correlation value - there isn‚Äôt a clear linear relationship between our two features. However, we‚Äôre going to examine another feature <code>LotConfig</code> which can tell us more about the relationship of <code>LotFrontage</code> and <code>LotArea</code>.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">LotConfig:  Lot configuration
  Inside    Inside lot
  Corner    Corner lot
  CulDSac   Cul-de-sac
  FR2       Frontage on 2 sides
            of property
  FR3       Frontage on 3 sides
            of property</code></pre></figure>

<p>Considering how <code>Corner</code> lots may have twice as much <code>LotFrontage</code> as <code>Inside</code> lots, and <code>FR2</code>s and <code>FR3</code>s should have comparatively more as well, first sorting into <code>LotConfig</code> might help us calculate a more accurate prediction.</p>

<p>First, we can examine the distribution of the <code>LotConfig</code> feature of the samples which are missing <code>LotFrontage</code>:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">mask6</span> <span class="o">=</span> <span class="n">merged_data</span><span class="p">[</span><span class="s">'LotFrontage'</span><span class="p">].</span><span class="n">isna</span><span class="p">()</span>
<span class="n">merged_data</span><span class="p">[</span><span class="n">mask6</span><span class="p">]</span>
  <span class="p">[</span><span class="s">'LotConfig'</span><span class="p">].</span><span class="n">value_counts</span><span class="p">()</span>

<span class="n">Inside</span>     <span class="mi">271</span>
<span class="n">Corner</span>     <span class="mi">104</span>
<span class="n">CulDSac</span>     <span class="mi">87</span>
<span class="n">FR2</span>         <span class="mi">20</span>
<span class="n">FR3</span>          <span class="mi">4</span></code></pre></figure>

<p>~77% (374/486) of our samples with a missing <code></code> value have either Inside or Corner as a <code>LotConfig</code>. To get a better idea of the correlation between these variables, we can look at how a simple linear model lines up on the subplots of each configuration:</p>

<section id="photos-grid">
  <img src="/assets/images/AreaFrontageSubplot0.svg" width="98%" />
  <img src="/assets/images/AreaFrontageSubplot1.svg" width="98%" />
  <img src="/assets/images/AreaFrontageSubplot2.svg" width="98%" />
  <img src="/assets/images/AreaFrontageSubplot3.svg" width="98%" />
  <img src="/assets/images/AreaFrontageSubplot4.svg" width="98%" />
</section>

<center>The code used to generate these graphs is available <a href="">on my github</a>.</center>

<p>Important to notice - I limited the <code>LotArea &lt;= 80000</code> since there is one outlier which skews all figures off to the right, at over 200000 square feet (200 when scaled, as seen here).</p>

<p>You can also see there is an issue with <code>CulDSac</code> properties - the linear model does not fit the data at all. Below, you can see this reflected in the correlations between <code>LotArea</code> and <code>LotFrontage</code> when grouped by <code>LotConfig</code>.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">mask6</span> <span class="o">=</span> <span class="n">merged_data</span><span class="p">[</span>
  <span class="s">'LotArea'</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">80000</span>
<span class="n">merged_data</span><span class="p">[</span><span class="n">mask6</span><span class="p">].</span><span class="n">groupby</span><span class="p">(</span>
  <span class="s">'LotConfig'</span><span class="p">)[</span>
    <span class="p">[</span><span class="s">'LotArea'</span><span class="p">,</span>
    <span class="s">'LotFrontage'</span><span class="p">]].</span><span class="n">corr</span><span class="p">()</span>

              <span class="n">LA</span>        <span class="n">LF</span>
<span class="n">LotConfig</span>
<span class="n">Inside</span>    <span class="n">LA</span>  <span class="mf">1.000000</span>  <span class="mf">0.630001</span>
          <span class="n">LF</span>  <span class="mf">0.630001</span>  <span class="mf">1.000000</span>
<span class="n">Corner</span>    <span class="n">LA</span>  <span class="mf">1.000000</span>  <span class="mf">0.787955</span>
          <span class="n">LF</span>  <span class="mf">0.787955</span>  <span class="mf">1.000000</span>
<span class="n">CulDSac</span>   <span class="n">LA</span>  <span class="mf">1.000000</span>  <span class="mf">0.195327</span>
          <span class="n">LF</span>  <span class="mf">0.195327</span>  <span class="mf">1.000000</span>
<span class="n">FR2</span>       <span class="n">LA</span>  <span class="mf">1.000000</span>  <span class="mf">0.827626</span>
          <span class="n">LF</span>  <span class="mf">0.827626</span>  <span class="mf">1.000000</span>
<span class="n">FR3</span>       <span class="n">LA</span>  <span class="mf">1.000000</span>  <span class="mf">0.835891</span>
          <span class="n">LF</span>  <span class="mf">0.835891</span>  <span class="mf">1.000000</span></code></pre></figure>

<p>Comparing this to our previous correlation calculation, there is a strict improvement in correlation for all <code>LotConfig</code> features except for <code>CulDSac</code> which could be due to the irregular shape of <code>CulDSac</code> lots, and their disproportionately small <code>LotFrontage</code> measure. I predict that, even with the poor predictions for <code>CulDSac</code> lots which make up 87 of our missing 486, we will have success using the linear relationship between <code>LotArea</code> and <code>LotFrontage</code> grouped by <code>LotConfig</code> to fill in our missing <code>LotFrontage</code> feature.</p>

<p>To do this, I will separate <code>merged_data</code> into 5 subsets (one for each possible value of <code>LotConfig</code>), remove the <code>NA</code>s from each subset, and then use the resulting subset to train a linear model.</p>

<p>The code used to do this is much easier to view <a href="">on github</a>, since I used a custom function, which, when applied to the data, is able to replace an <code>NA</code> <code>LotFrontage</code> value with a predicted one.</p>

<p>To see how this affected our data, we can compare the previous graphs to updated ones - we should be able to see new data points running along our previously displayed line of best fit for each <code>LotConfig</code>.</p>

<section id="photos-two">
  <img src="/assets/images/AreaFrontageSubplot0.svg" width="49%" />
  <img src="/assets/images/AreaFrontageSubplotPostFill0.svg" width="49%" />
</section>

<section id="photos-two">
  <img src="/assets/images/AreaFrontageSubplot1.svg" width="49%" />
  <img src="/assets/images/AreaFrontageSubplotPostFill1.svg" width="49%" />
</section>
<section id="photos-two">
  <img src="/assets/images/AreaFrontageSubplot2.svg" width="49%" />
  <img src="/assets/images/AreaFrontageSubplotPostFill2.svg" width="49%" />
</section>
<section id="photos-two">
  <img src="/assets/images/AreaFrontageSubplot3.svg" width="49%" />
  <img src="/assets/images/AreaFrontageSubplotPostFill3.svg" width="49%" />
</section>
<section id="photos-two">
  <img src="/assets/images/AreaFrontageSubplot4.svg" width="49%" />
  <img src="/assets/images/AreaFrontageSubplotPostFill4.svg" width="49%" />
</section>

<p>It is not perfect, but it does let us keep <code>LotFrontage</code> as a feature, and this might help boost the performance of our algorithm. Another way we can visualize how the data was changed is by using <code>.describe()</code> on <code>merged_data['LotFrontage']</code> before and after filling.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python">         <span class="n">Prefill</span>  <span class="n">Postfill</span> 
<span class="n">count</span>    <span class="mf">2433.00</span>   <span class="mf">2919.00</span>    
<span class="n">mean</span>       <span class="mf">69.30</span>     <span class="mf">70.17</span>
<span class="n">std</span>        <span class="mf">23.34</span>     <span class="mf">27.03</span>
<span class="nb">min</span>        <span class="mf">21.00</span>     <span class="mf">21.00</span>
<span class="mi">25</span><span class="o">%</span>        <span class="mf">59.00</span>     <span class="mf">58.32</span>
<span class="mi">50</span><span class="o">%</span>        <span class="mf">68.00</span>     <span class="mf">68.00</span>
<span class="mi">75</span><span class="o">%</span>        <span class="mf">80.00</span>     <span class="mf">80.00</span>
<span class="nb">max</span>       <span class="mf">313.00</span>    <span class="mf">806.26</span></code></pre></figure>

<h4 id="garagearea--garagecars">GarageArea / GarageCars</h4>

<p>First, we should confirm that the single sample that is missing both <code>GarageArea</code> and <code>GarageCars</code> has a <code>GarageType</code> other than <code>None</code>, otherwise we will simply fill these in with <code>0</code>.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">merged_data</span><span class="p">[</span>
 <span class="n">merged_data</span><span class="p">[</span>
  <span class="s">'GarageCars'</span><span class="p">].</span><span class="n">isna</span><span class="p">()][[</span>
   <span class="s">'GarageType'</span><span class="p">,</span>
   <span class="s">'GarageArea'</span><span class="p">,</span>
   <span class="s">'GarageCars'</span><span class="p">]]</span>

         <span class="n">GType</span>  <span class="n">GArea</span>  <span class="n">GCars</span>
<span class="mi">2576</span>    <span class="n">Detchd</span>    <span class="n">NaN</span>    <span class="n">NaN</span></code></pre></figure>

<p>Now, we can fill these based on the average <code>GarageArea</code> of <code>Detchd</code> garages, and the most common value for <code>GarageCars</code> of <code>Detchd</code> garages.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">for</span> <span class="n">ds</span> <span class="ow">in</span> <span class="p">(</span>
  <span class="n">test_data</span><span class="p">,</span>
  <span class="n">train_data</span><span class="p">,</span>
  <span class="n">merged_data</span><span class="p">):</span>
    <span class="n">ds</span><span class="p">[</span><span class="s">'GarageCars'</span><span class="p">]</span> <span class="o">=</span> \
      <span class="n">ds</span><span class="p">[</span><span class="s">'GarageCars'</span><span class="p">].</span><span class="n">fillna</span><span class="p">(</span>
      <span class="n">groupby</span><span class="p">(</span><span class="s">'GarageType'</span><span class="p">)</span> \
      <span class="p">[</span><span class="s">'GarageCars'</span><span class="p">].</span><span class="n">transform</span><span class="p">(</span>
      <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">.</span><span class="n">mode</span><span class="p">().</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="n">ds</span><span class="p">[</span><span class="s">'GarageArea'</span><span class="p">]</span> <span class="o">=</span> \
      <span class="n">ds</span><span class="p">[</span><span class="s">'GarageArea'</span><span class="p">].</span><span class="n">fillna</span><span class="p">(</span>
      <span class="n">groupby</span><span class="p">(</span><span class="s">'GarageType'</span><span class="p">)</span> \
      <span class="p">[</span><span class="s">'GarageArea'</span><span class="p">].</span><span class="n">transform</span><span class="p">(</span>
      <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">.</span><span class="n">mean</span><span class="p">().</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span></code></pre></figure>

<p><br /></p>

<hr />

<h3 id="reviewing-the-cleaned-data">Reviewing the Cleaned Data</h3>

<p>We can now run the same script to generate our summary of the data - we should see there are no more <code>NA</code> values!</p>

<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th class="text">Feature</th>
      <th class="numeric">NA Count</th>
      <th class="numeric">Percentage</th>
      <th class="text">Data Type</th>
      <th class="text">Overview</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th data-title="Feature" class="text">Id</th>
      <td data-title="NA Count" class="numeric">0</td>
      <td data-title="% Missing" class="numeric">0.0</td>
      <td data-title="Data Type" class="numeric">int64</td>
      <td data-title="Overview" class="text">[1, 2919, 1460, 1460]</td>
    </tr>
    <tr>
      <th data-title="Feature" class="text">MSSubClass</th>
      <td data-title="NA Count" class="numeric">0</td>
      <td data-title="% Missing" class="numeric">0.0</td>
      <td data-title="Data Type" class="numeric">int64</td>
      <td data-title="Overview" class="text">[20, 190, 57, 50]</td>
    </tr>
    <tr>
      <th data-title="Feature" class="text">MSZoning</th>
      <td data-title="NA Count" class="numeric">0</td>
      <td data-title="% Missing" class="numeric">0.0</td>
      <td data-title="Data Type" class="text">object</td>
      <td data-title="Overview" class="text">[RL, RM, C (all), FV, RH]</td>
    </tr>
    <tr>
      <th data-title="Feature" class="text">LotFrontage</th>
      <td data-title="NA Count" class="numeric">0</td>
      <td data-title="% Missing" class="numeric">0.0</td>
      <td data-title="Data Type" class="numeric">float64</td>
      <td data-title="Overview" class="text">[21, 806, 70, 68]</td>
    </tr>
    <tr>
      <th class="styling-space">...</th>
      <td class="disappearing">...</td>
      <td class="disappearing">...</td>
      <td class="disappearing">...</td>
      <td class="disappearing">...</td>
    </tr>
  </tbody>
</table>

<p><a class="read-more-link" href="/assets/cleaned-missing-values-summary.html"> See full table </a></p>

<p>No more NAs!!</p>

<p>This has been a beast of a post, both in length and content! Now that we have a squeaky clean dataset, the next step will be some feature engineering, and possibly some exploration into feature selection using a Random Forest Regressor.</p>

<p>Thank you for reading, until next time!</p>
:ET